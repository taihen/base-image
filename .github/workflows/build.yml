name: Build & Publish Multi-Arch Distroless glibc Base

on:
  push:
    branches: [main]
  schedule:
    # Run daily at 5 AM UTC to pick up the latest package updates from Wolfi
    - cron: "0 5 * * *"

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write # Required for keyless signing with Cosign
    outputs:
      digest: ${{ steps.extract-digest.outputs.digest }}
      has-changes: ${{ steps.compare.outputs.has-changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download previous digest artifact
        uses: actions/download-artifact@v4
        id: download
        continue-on-error: true
        with:
          name: previous-digest
          path: previous-digest

      - name: Read previous digest
        id: previous
        run: |
          if [ -f previous-digest/digest.txt ]; then
            echo "digest=$(cat previous-digest/digest.txt)" >> $GITHUB_OUTPUT
            echo "Previous digest found: $(cat previous-digest/digest.txt)"
          else
            echo "No previous digest found"
            echo "digest=" >> $GITHUB_OUTPUT
          fi

      - name: Build, Publish, and Sign with wolfi-act
        id: build
        uses: wolfi-dev/wolfi-act@main
        env:
          COSIGN_EXPERIMENTAL: "1"
          OCI_HOST: ghcr.io
          OCI_REPO: ${{ github.repository }}
        with:
          packages: apko,cosign
          command: |
            set -e

            # Log in to the GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | apko login "$OCI_HOST" -u "${{ github.actor }}" --password-stdin

            # Create a directory for the SBOMs
            mkdir -p sbom-output

            # Publish the multi-arch image using apko, which also generates an SBOM.
            # The digest is captured for signing.
            digest=$(apko publish apko.yaml "$OCI_HOST/$OCI_REPO" \
              --sbom-path=sbom-output)

            # Sign the image digest using Cosign keyless signing.
            cosign sign --yes "$digest"

            # Save the digest to a file that can be read outside the container
            echo "$digest" > digest.txt

      - name: Extract digest
        id: extract-digest
        run: |
          # Read the digest from the file created in the container
          DIGEST=$(cat digest.txt)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Extracted digest: $DIGEST"

      - name: Compare digests
        id: compare
        run: |
          PREVIOUS="${{ steps.previous.outputs.digest }}"
          CURRENT="${{ steps.extract-digest.outputs.digest }}"

          echo "Previous digest: $PREVIOUS"
          echo "Current digest: $CURRENT"

          if [ -z "$PREVIOUS" ]; then
            echo "No previous digest, marking as changed"
            echo "has-changes=true" >> $GITHUB_OUTPUT
          elif [ "$PREVIOUS" != "$CURRENT" ]; then
            echo "Digests differ, marking as changed"
            echo "has-changes=true" >> $GITHUB_OUTPUT
          else
            echo "Digests are identical, no changes"
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Save current digest
        run: |
          mkdir -p current-digest
          echo "${{ steps.extract-digest.outputs.digest }}" > current-digest/digest.txt
          # Clean up temporary file
          rm -f digest.txt

      - name: Upload current digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: previous-digest
          path: current-digest/digest.txt
          retention-days: 7
          overwrite: true

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom-output/

  test:
    needs: build
    if: needs.build.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create test Go application
        run: |
          mkdir -p test-app
          cat > test-app/main.go << 'EOF'
          package main

          import (
              "fmt"
              "os"
              "runtime"
          )

          func main() {
              fmt.Printf("Hello from base-image test!\n")
              fmt.Printf("OS: %s\n", runtime.GOOS)
              fmt.Printf("Arch: %s\n", runtime.GOARCH)
              fmt.Printf("Go version: %s\n", runtime.Version())
              fmt.Printf("User: %d\n", os.Getuid())
              fmt.Printf("Group: %d\n", os.Getgid())

              // Test that we can read environment variables
              if testVar := os.Getenv("TEST_VAR"); testVar != "" {
                  fmt.Printf("TEST_VAR: %s\n", testVar)
              }

              // Test that we're running as non-root (65532)
              if os.Getuid() != 65532 {
                  fmt.Printf("ERROR: Expected UID 65532, got %d\n", os.Getuid())
                  os.Exit(1)
              }

              fmt.Println("All tests passed!")
          }
          EOF

      - name: Create test Dockerfile
        run: |
          cat > test-app/Dockerfile << 'EOF'
          # Declare build args at the top for global scope
          ARG BASE_IMAGE

          # Build stage
          FROM golang:1.23-alpine AS builder
          WORKDIR /build
          COPY main.go .
          # Build for both architectures
          ARG TARGETARCH
          RUN CGO_ENABLED=1 go build -ldflags="-s -w" -o hello main.go

          # Runtime stage using our base image
          FROM $BASE_IMAGE
          COPY --from=builder /build/hello /hello
          USER 65532:65532
          ENTRYPOINT ["/hello"]
          EOF

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test image on linux/amd64
        run: |
          echo "Testing linux/amd64..."
          docker buildx build \
            --platform linux/amd64 \
            --build-arg BASE_IMAGE=${{ needs.build.outputs.digest }} \
            --load \
            -t test-app:amd64 \
            test-app/

          # Run the test
          docker run --rm \
            --platform linux/amd64 \
            -e TEST_VAR="Hello from test" \
            test-app:amd64

      - name: Test image on linux/arm64
        run: |
          echo "Testing linux/arm64..."
          docker buildx build \
            --platform linux/arm64 \
            --build-arg BASE_IMAGE=${{ needs.build.outputs.digest }} \
            --load \
            -t test-app:arm64 \
            test-app/

          # Run the test (will use qemu if not on arm64 host)
          docker run --rm \
            --platform linux/arm64 \
            -e TEST_VAR="Hello from test" \
            test-app:arm64

      - name: Test multi-platform build
        run: |
          echo "Testing multi-platform build..."
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --build-arg BASE_IMAGE=${{ needs.build.outputs.digest }} \
            -t test-app:multi \
            test-app/

          echo "Multi-platform build successful!"

      - name: Security scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.digest }}
          format: "table"
          exit-code: "0" # Don't fail on vulnerabilities, just report
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

  release:
    needs: [build, test]
    if: needs.build.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate release tag
        id: tag
        run: |
          # Generate a date-based tag for the release
          TAG="v$(date +'%Y.%m.%d')"
          COUNTER=0

          # Check if tag already exists and increment counter if needed
          while git ls-remote --tags origin | grep -q "refs/tags/${TAG}"; do
            COUNTER=$((COUNTER + 1))
            TAG="v$(date +'%Y.%m.%d').${COUNTER}"
          done

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated tag: $TAG"

      - name: Download SBOM artifact
        uses: actions/download-artifact@v4
        with:
          name: sbom
          path: sbom-output

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: Release ${{ steps.tag.outputs.tag }}
          body: |
            ## ğŸš€ Automated Release

            This release was automatically generated due to changes detected in the container image build.

            ### ğŸ“¦ Container Image
            - **Image**: `ghcr.io/${{ github.repository }}:latest`
            - **Digest**: `${{ needs.build.outputs.digest }}`

            ### ğŸ“‹ What's Changed
            This release includes the latest security updates and package changes from the Wolfi base image.

            ### ğŸ” Verification
            You can verify the image signature using:
            ```bash
            cosign verify ${{ needs.build.outputs.digest }} \
              --certificate-identity=https://github.com/${{ github.repository }}/.github/workflows/build.yml@refs/heads/main \
              --certificate-oidc-issuer=https://token.actions.githubusercontent.com
            ```

            ### ğŸ“„ SBOM
            The Software Bill of Materials (SBOM) is attached to this release.
          files: |
            sbom-output/*
          generate_release_notes: false
          draft: false
          prerelease: false
